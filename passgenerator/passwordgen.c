#include "hash.h"
#define error(m, c) do{fprintf(stderr, "%s\n", m);exit(c);}while(0)
hashset h;
char* words[100000];
static int N;
typedef struct{
	int from_index;
	int to_index;
}producer_task;
static pthread_mutex_t mutex;
void* producer(void* args){
	producer_task* task = (producer_task*)args;
	pthread_mutex_lock(&mutex);
	for(int j = task->from_index; j <= task->to_index;j++){
		insert(&h, words[j]);
	}
	pthread_mutex_unlock(&mutex);
}

static int m;//number of consumer threads
static int k;//number of passwords that need to be generated by this program
static int l;//number of words per passwords
void* consumer(void* args){
	char password[25*l];
	for(int i = 0; i < k/m;i++){
		for(int j = 0; j < l;j++){
			pthread_mutex_lock(&mutex);
			int result = 0;
			char* random_word = words[rand()%N];
			while(!result){
				result = delete_value(&h, random_word);
				if(!result)
					random_word = words[rand()%N];
			}
			pthread_mutex_unlock(&mutex);
			//change it to a random word generator
			//words[rand()%N]
			//call delete_value function to try removing the word from hash table
			//don't forget to lock/unlock the mutex before/after the remove operation
			//check the return value of delete_value function. 
			//If the return value is zero, try again after doing j--

			if(j)//not the first word of the password
				sprintf(password, "%s,%s", password, random_word);
			else//first word
				strcpy(password, random_word);
		}
		printf("%s\n", password);
	}
}
int main(int argc, char** argv) {
	srand(time(NULL));
	pthread_mutex_init(&mutex, NULL);//initializing the mutex for hash set
	int n;//number of producer threads
	char* file;//dictionary file (path) name (extension)
	if(argc != 11)
		error("fatal error: use the following CLAs: -p n -c m -f -n k file -l l", 1);
	char* message = (char*) malloc(100);
	while(*++argv){
		if(argv[0][0] != '-'){
			sprintf(message, "fatal error: illegal command-line detected: %s", *argv);
			error(message, 2);
		}
		switch(argv[0][1]){
			case 'p':
			sscanf(*(++argv), "%d", &n);
			break;
			case 'c':
			sscanf(*(++argv), "%d", &m);
			break;
			case 'l':
			sscanf(*(++argv), "%d", &l);
			break;
			case 'n':
			sscanf(*(++argv), "%d", &k);
			break;
			case 'f':
			file = (char*) malloc(100);
			sscanf(*(++argv), "%s", file);
			break;
			default:
			sprintf(message, "fatal error: flag -%c is not supported", argv[0][1]);
			error(message, 3);
		}
	}
	if(k % m)
		error("fatal error: requested number of passwords is not divisible by the given number of consumers", 4);
	h = set_init();
	char word[500];
	FILE* f = fopen(file, "r");
	int i = 0;
	while(fgets(word, 500, f)){
		int n = strlen(word);
		if(!n)continue;
		if(word[n-1] == '\n')
			word[n-1] = '\0';
		words[i++] = strdup(word);
	}
	fclose(f);
	N = i;//# of words in dictionary!
	//You need to construct n different producer tasks
	//producer #0: inserts words[0...N/n - 1] to hashset
	//producer #1: inserts words[N/n...2 * N/n - 1] to hashset
	//producer #2: inserts words[2 * N/n ... 3 * N/n - 1] to hashset
	//...
	//producer #s: inserts words[s * N/n ... (s+1) * N/n - 1] to hashset
	//...
	//producer #n-1: inserts words[(n-1) * N/n ... n * N / n - 1] to hashset
	//Create a prdoucer thread for each task...
	pthread_t producer_threads[n];
	for(int j = 0; j < n;j++){
		producer_task* task = (producer_task*)malloc(sizeof(producer_task));
		task->from_index = j * N / n;
		task->to_index = (j + 1) * N / n - 1;
		pthread_create(&producer_threads[j], NULL, producer, task);
	}
	for(int j = 0; j < n;j++){
		pthread_join(producer_threads[j], NULL);
	}
	//end of production phase...
	//You need to join all created producer threads here in a for-loop
	
	
	
	
	//Here, we start the consumption phase
	//Create m consumer threads
	pthread_t consumer_threads[m];
	for(int j = 0; j < m;j++){
		pthread_create(&consumer_threads[j], NULL, consumer, NULL);
	}
	for(int j = 0; j < m;j++){
		pthread_join(consumer_threads[j], NULL);
	}
	
	//Join all consumer threads 
	return 0;
}